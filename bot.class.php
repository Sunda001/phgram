<?php
/**
* A simple class to Telegram bot development with PHP.
*
* Based on TelegramBotPHP (https://github.com/Eleirbag89/TelegramBotPHP)
*
* @author Cezar Pauxis (https://t.me/usernein)
* @license https://github.com/usernein/phgram/blob/master/LICENSE
*/
class Bot {
	/**
	* The bot token. Acessible from outside.
	*
	* @var string $bot_token
	*/
	public $bot_token = '';
	
	/**
	* The update data. Automatically filled when a new instance of the class is created.
	* All update-related methods uses this array. Can be set (again) using setData.
	*
	* @var array $data
	*/
	private $data = [];
	
	/**
	* The type of the update. e.g. callback_query, message, edited_message, inline_query..
	* 
	* @var string $update_type
	**/
	private $update_type = '';
	
	/**
	* If TRUE, you will be notified when the request fails. Set the $debug_admin to your id
	*
	* @var bool $debug
	* @var $debug_admin
	**/
	public $debug = FALSE;
	public $debug_admin;
	
	/**
	* Contructor. Only needs the bot token. Fills the internal data and bot_token.
	*
	* @param string $bot_token Token generated by @BotFather
	* @param chat to send API errors
	*/
	public function __construct(string $bot_token, $debug_chat = FALSE) {
		$this->bot_token = $bot_token;
		$this->data = $this->getData();
		$this->update_type = @array_keys($this->data)[1];
		if ($debug_chat) {
			$this->debug_admin = $debug_chat;
			$this->debug = TRUE;
		}
	}
	
	/**
	* Private method. All method gets called by using cURL.
	*
	* @param string $url Url to API
	* @param array $content The method's parameters
	*
	* return string A JSON containing the method's result. See https://core.telegram.org/bots/api#making-requests.
	*/
	private function sendAPIRequest(string $url, array $content) {
		$ch = curl_init($url);
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
		curl_setopt($ch, CURLOPT_POST, TRUE);
		curl_setopt($ch, CURLOPT_POSTFIELDS, $content);
		$result = curl_exec($ch);
		curl_close($ch);
		return $result;
	}
	
	/**
	* Method to respond webhook. See https://core.telegram.org/bots/api#making-requests-when-getting-updates.
	*
	* @param string $method Method's name, according to Bot API.
	* @param array $arguments Method's parameters, according to Bot API.
	*/
	public function respondWebhook(string $method, array $arguments) {
		header("Content-Type: application/json");
		$arguments['method'] = $method;
		echo json_encode($arguments);
	}
	
	/**
	* The __call() magic method is called when the code calls a non-existing method. So you can call any API method and it will be called with a POST request.
	* Be careful: __call() will be called with non-api methods, too. By the way, all methods are case-insentitive.
	*
	* @param string $method Method's name, according to Bot API.
	* @param array $arguments Method's parameters, according to Bot API.
	*
	* return array An array containing the method's result. We'll call it as MethodResult. See https://core.telegram.org/bots/api#making-requests.
	*/
	public function __call(string $method, array $arguments = NULL) {
		if (!$arguments) $arguments = [[]];
		$url = "https://api.telegram.org/bot{$this->bot_token}/{$method}";
		$reply = $this->sendAPIRequest($url, $arguments[0]);
		
		$reply = new MethodResult($reply);
		if (!$reply['ok'] && $this->debug && error_reporting() > 0) {
			$this->send(json_encode($reply->data), ['chat_id' => $this->debug_admin]);
		}
		return $reply;
	}
	
	/**
	* Use it to download a file (present in Telegram servers) to your server.
	* Unfortunately it halts a bit during execution of code.
	*
	* @param string $file_id File id.
	* @param string $local_file_path Path to save the file. Optional. Default is according to the original file name, in the working directory.
	*
	* return array [filename = saved file's name, filepath = saved file's path, filesize = saved file's size in bytes]
	*/
	public function download_file(string $file_id, string $local_file_path = NULL) {
		$telegram_file_info = $this->getFile(['file_id' => $file_id])['result'];
		$telegram_file_path = $telegram_file_info['file_path'];
		if (!$local_file_path) {
			$local_file_path = $telegram_file_info['file_name'];
		}
		$file_url = "https://api.telegram.org/file/bot{$this->bot_token}/{$telegram_file_path}";
		$in = fopen($file_url, 'rb');
		$out = fopen($local_file_path, 'wb');
 
		while ($chunk = fread($in, 8192)) {
			fwrite($out, $chunk, 8192);
		}
		fclose($in);
		fclose($out);
		
		return ['filename' => basename($local_file_path), 'filepath' => realpath($local_file_path), 'filesize' => filesize($local_file_path)];
	}
	
	/**
	* Read a file
	*
	* @param string file_id
	* 
	* return string Content
	*/
	public function read_file(string $file_id) {
		$file_path = $this->getFile(['file_id' => $file_id])->file_path;
		$file_url = "https://api.telegram.org/file/bot{$this->bot_token}/{$file_path}";
		return file_get_contents($file_url);
	}
	
	/**
	* Quicly sends a message with default parameters.
	* Note that this function is a shortcut. It requires only one parameter : the text.
	* A second parameter can be passed: the array of custom parameters to override the default ones:
	 * [chat_id = current chat, parse_mode = HTML, disable_web_page_preview = TRUE]
	*
	* @param string text The text to send (0-4096)
	* @param array $params (Optional) Custom parameters.
	*
	* return array MethodResult (sendMessage)
	*/
	public function send(string $text, array $params = []) {
		$default = ['chat_id' => $this->ChatID(), 'parse_mode' => 'HTML', 'disable_web_page_preview' => TRUE, 'text' => $text];
		if ($params == []) {
			return $this->sendMessage($default);
		} else {
			foreach ($params as $param => $value) {
				$default[$param] = $value;
			}
			return $this->sendMessage($default);
		}
	}
	
	/**
	* Replies a message (specified by reply_to()).
	* Same as send(), but uses reply_to() to get a message_id to reply.
	*
	* @param string $text The text to send (0-4096)
	* @param array $params (Optional) Custom parameters.
	*
	* return array MethodResult (sendMessage)
	*/
	public function reply(string $text, array $params = []) {
		$default = ['chat_id' => $this->ChatID(), 'parse_mode' => 'HTML', 'disable_web_page_preview' => TRUE, 'reply_to_message_id' => $this->MessageID(), 'text' => $text];
		if ($params == []) {
			return $this->sendMessage($default);
		} else {
			foreach ($params as $param => $value) {
				$default[$param] = $value;
			}
			$default['text'] = $text;
			return $this->sendMessage($default);
		}
	}
	
	/**
	* Use to quickly edit a message.
	* Same syntax as reply() and send(), but with an additional value.
	*
	* @param string $text The new text
	* @param int $message_id Id of message to edit.
	* @param array $params (Optional) Custom parameters.
	*
	* return array MethodResult (editMessageTexf)
	*/
	public function edit(string $text, array $params = []) {
		$default = ['chat_id' => $this->ChatID(), 'parse_mode' => 'HTML', 'disable_web_page_preview' => TRUE, 'text' => $text, 'message_id' => $this->MessageID()];
		if ($params == []) {
			return $this->editMessageText($default);
		} else {
			foreach ($params as $param => $value) {
				$default[$param] = $value;
			}
			$default['text'] = $text;
			return $this->editMessageText($default);
		}
	}
 
	/**
	* Quickly uploads a local file.
	* Has the same default paramenters of send().
	* 
	* @param string $filename Relative path to file
	* @param array $params (Optional) Custom parameters.
	*
	* return array MethodResult (sendDocument)
	*/
	public function doc(string $filename, array $params = []) {
		$default = ['chat_id' => $this->ChatID(), 'parse_mode' => 'HTML', 'disable_web_page_preview' => TRUE];
		$document = curl_file_create($filename);
		if ($document) {
			$this->action("upload_document");
		}
		$default['document'] = $document;
		
		if ($params == []) {
			return $this->sendDocument($default);
		} else {
			foreach ($params as $param => $value) {
				$default[$param] = $value;
			}
			return $this->sendDocument($default);
		}
	}
	
	/**
	* Quickly sends a chat action.
	* Has the chat_id set to current chat, by default.
	* 
	* @param string $action (Optional) Action to send. Defaults to 'typing'.
	* @param array $params (Optional) Custom parameters.
	*
	* return array MethodResult (sendChatAction)
	*/
	public function action(string $action = 'typing', array $params = []) {
		$default = ['chat_id' => $this->ChatID(), 'action' => $action];
		if ($params == []) {
			return $this->sendChatAction($default);
		} else {
			foreach ($params as $param => $value) {
				$default[$param] = $value;
			}
			return $this->sendChatAction($default);
		}
	}
	
	/**
	Quickly generates a mention
	
	@param int user_id
	@param bool html Use html? Default is TRUE.
	
	@return string Mention to the specified user
	*/
	public function mention($user_id, $parse_mode = 'html') {
		$parse_mode = strtolower($parse_mode);
		$info = @$this->Chat($user_id);
		if (!$info) {
			return $user_id;
		}
		$mention = isset($info['username'])? "@{$info['username']}" : ($parse_mode == 'html'? "<a href='tg://user?id={$user_id}'>{$info['first_name']}</a>" : "[{$info['first_name']}](tg://user?id={$user_id})");
		return $mention;
	}
	
	/**
	* Use it to get the data of the update.
	* 
	* @param void
	*
	* return array Update. See https://core.telegram.org/bots/api#update
	*/
	public function getData() {
		if (!$this->data) {
			$update_as_json = file_get_contents('php://input');
			$this->data = json_decode($update_as_json, TRUE);
		}
		
		return $this->data;
	}
 
	/**
	* Changes the value of internal $data. Then it can be used in Text(), ChatID(), UserID()...
	* 
	* @param array $data New value to use
	*/
	public function setData(array $data) {
		$this->data = $data;
		$this->update_type = @array_keys($this->data)[1];
	}
	
	/**
	* Use it to get the type of an update.
	* All updates has the following syntax: [update_id = integer, TYPE = array]
	* Well, this method will return the TYPE.
	* 
	* @param void
	*
	* @return string Update's type.
	*/
	public function getUpdateType() {
		return $this->update_type;
	}
	
	/**
	* Search and return a value from update
	*
	* @param string $search The value
	**/
	public function getValue(string $search) {
		return $this->data[$this->update_type][$search] ?? $this->data[$this->update_type]['message'][$search] ?? NULL;
	}
	
	/**
	* Use to check if a user is in the specified chat.
	*
	* @param int $user_id Id of user.
	* @param $chat_id Id of chat.
	*
	* return bool
	*/
	public function in_chat(int $user_id, $chat_id) {
		$member = $this->getChatMember(['chat_id' => $chat_id, 'user_id' => $user_id]);
		if (!$member['ok'] || in_array($member['result']['status'], ['left', 'restricted', 'kicked'])) {
			return FALSE;
		}
		
		return TRUE;
	}
	
	/**
	* Use it to quickly check if the chat is a supergroup.
	*
	* @param void
	*
	* return bool
	*/
	public function is_group() {
		$chat = $this->getValue('chat');
		if (!$chat) return FALSE;
		return ($chat['type'] == 'supergroup') || ($chat['type'] == 'group');
	}
	
	/**
	* Use it to quickly check if the chat is a private conversation (user-bot).
	*
	* @param void
	*
	* return bool
	*/
	public function is_private() {
		$chat = $this->getValue('chat');
		if (!$chat) return FALSE;
		return $chat['type'] == 'private';
	}
	
	/**
	* Use it to check if an user is admin of specified chat
	*
	* @param int $user_id (Optional) Id of user. Default is the current user (the sender)
	* @param $chat_id (Optional) Id of chat. Default is the current chat.
	*
	* @return bool
	*/
	public function is_admin($user_id = NULL, $chat_id = NULL) {
		if (!$user_id) {
			$user_id = $this->UserID();
		}
		if (!$chat_id) {
			$chat_id = $this->ChatID();
		}
		$member = $this->getChatMember(['chat_id' => $chat_id, 'user_id' => $user_id]);
		return in_array($member['result']['status'], ['administrator', 'creator']);
	}
	
	/**
	* You can use any method below to get, dinamically, specific info about an update.
	* Simply call '$text = $bot->Text();' and you will get the text of the update, regardless of type (i.e. channel_post, message, edited_* or even callback_query).
	* If the update does not have 'text', the method will return NULL
	*
	* @param void
	*/
	public function Text() {
		return $this->getValue('text');
	}
 
	public function ChatID() {
		return $this->getValue('chat')['id'] ?? NULL;
	}

	public function ChatType() {
		return $this->getValue('chat')['type'] ?? NULL;
	}
	
	public function MessageID() {
		return $this->getValue('message_id');
	}
 
	public function Date() {
		return $this->getValue('date');
	}
 
	public function UserID() {
		return $this->getValue('from')['id'] ?? NULL;
	}
 
	public function FirstName() {
		return $this->getValue('from')['first_name'] ?? NULL;
	}
 
	public function LastName() {
		return $this->getValue('from')['last_name'] ?? NULL;
	}
	
	public function Name() {
		$first_name = $this->FirstName();
		$last_name = $this->LastName();
		if ($first_name) {
			$name = $first_name.($last_name? " {$last_name}" : '');
			return $name;
		}
		
		return NULL;
	}
 
	public function Username() {
		return $this->getValue('from')['username'] ?? NULL;
	}
	
	public function Language() {
		return $this->getValue('from')['language_code'] ?? NULL;
	}
 
	public function ReplyToMessage() {
		return $this->getValue('reply_to_message');
	}
 
	public function Caption() {
		return $this->getValue('caption');
	}
	
	public function InlineQuery() {
		return $this->data['inline_query'] ?? NULL;
	}
 
	public function ChosenInlineResult() {
		return $this->data['chosen_inline_result'] ?? NULL;
	}
 
	public function ShippingQuery() {
		return $this->data['shipping_query'] ?? NULL;
	}
 
	public function PreCheckoutQuery() {
		return $this->data['pre_checkout_query'] ?? NULL;
	}
 
	public function CallbackQuery() {
		return $this->data['callback_query'] ?? NULL;
	}
 
	public function Location() {
		return $this->getValue('location');
	}
 
	public function Photo() {
		return $this->getValue('photo');
	}
 
	public function Video() {
		return $this->getValue('video');
	}
 
	public function Document() {
		return $this->getValue('document');
	}
 
	public function UpdateID() {
		return $this->data['update_id'] ?? NULL;
	}
	
	public function ForwardFrom() {
		return $this->getValue('forward_from');
	}
 
	public function ForwardFromChat() {
		return $this->getValue('forward_from_chat');
	}
	
	public function Entities() {
		return $this->getValue('entities') ?? $this->getValue('caption_entities');
	}
	/**
	* Shortcut to getChat.
	*
	* @param (Optional) $chat_id ID of chat. Default is the current chat.
	*
	* return array Chat object || bool FALSE. See https://core.telegram.org/bots/api#chat
	*/
	public function Chat($chat_id = NULL) {
		if (!$chat_id) {
			$chat_id = $this->ChatID();
		}
		$chat = $this->getChat(['chat_id' => $chat_id]);
		if ($chat['ok']) {
			return $chat['result'];
		}
		return FALSE;
	}
}

/** 
* Object interface of methods result
*/
class MethodResult implements ArrayAccess {
	public $data = [];
	public $ok = NULL;
	public $result = NULL;
	public $description = NULL;
	public $error_code = NULL;
	public $parameters = NULL;
	
	public function __construct(string $json_result) {
		$this->data = json_decode($json_result, TRUE);
		
		$data = json_decode($json_result);
		foreach ($data as $key => $value) {
			$this->$key = $value;
		}
	}
	
	public function __toString() {
		return json_encode($this->data);
	}
	
	public function __get($index) {
		return $this->$index ?? $this->result->$index ?? NULL;
	}
	
	public function offsetGet($index) {
		return $this->data[$index] ?? $this->data['result'][$index] ?? NULL;
	}
	
	public function offsetSet($index, $value) {
		if (isset($this->data[$index])) {
			$this->data[$index] = $value;
		} else if (isset($this->data['result'][$index])) {
			$this->data['result'][$index] = $value;
		} else {
			$this->$index = $value;
		}
	}
	
	public function offsetExists($index) {
		return (isset($this->data[$index]) || isset($this->data['result'][$index]));
	}
	
	public function offsetUnset($index) {
		if (isset($this->data[$index])) {
			unset($this->data[$index]);
		} else if (isset($this->data['result'][$index])) {
			unset($this->data['result'][$index]);
		} else {
			unset($this->$index);
		}
	}
}

/**
* Build an InlineKeyboardButton object.
* The type can be ommitted. Passing two parameters (text and value), the type will be assumed 'callback_data'.
*
* @param string $text Text to show in the button.
* @param string $param Value to button.
* @param string $type (Optional) Type of button. Defaults to callback_data.
*
* return array InlineKeyboardButton object. See https://core.telegram.org/bots/api#inlinekeyboardbutton
*/
function btn($text, string $value, string $type = 'callback_data') {
	return ['text' => $text, $type => $value];
}
 
/**
* Build a KeyboardButton object.
* Is recommended to use only when you need to request contact or location.
* If you need a simple text button, pass a string instead of KeyboardButton.
*
* @param string $text Button text.
* @param bool (Optional) $request_contact Will the button ask for user's phone number? Defaults to FALSE.
* @param bool (Optional) $request_location Will the button ask for user's location? Defaults to FALSE.
* 
* return array KeyboardButton object. See https://core.telegram.org/bots/api#keyboardbutton
*/
function kbtn($text, bool $request_contact = FALSE, bool $request_location = FALSE) {
	$replyMarkup = [
		'text' => $text,
		'request_contact' => $request_contact,
		'request_location' => $request_location,
	];
	return $replyMarkup;
}
 
/**
* Build a ReplyKeyboardMarkup object.
* 
* @param array $options Array (keyboard/set of lines) of array (line/set of buttons) of KeyboardButton, generated by kbtn() or strings.
* @param bool $onetime (Optional) If TRUE, the keyboard will be closed after using a button. Default is  FALSE.
* @param bool $resize (Optional) If TRUE, the keyboard will allow user's client to resize it. Default is FALSE.
* @param bool $selective (Optional) If TRUE, the keyboard willpp appear only to certain users. Dafault is TRUE.
*
* return string/JSON ReplyKeyboardMarkup object. See https://core.telegram.org/bots/api#replykeyboardmarkup
*/
function kb(array $options, bool $resize_keyboard = FALSE, bool $one_time_keyboard = FALSE, bool $selective = TRUE) {
	$replyMarkup = [
		'keyboard' => $options,
		'resize_keyboard' => $resize_keyboard,
		'one_time_keyboard' => $one_time_keyboard,
		'selective' => $selective,
	];
	return json_encode($replyMarkup, 480);
}
 
/**
* Build an InlineKeyboardMarkup object.
*
* @param array $options Array (keyboard/set of lines) of array (line/set of buttons) of array of parameters to pass to btn(). See the documentation for example.
*
* return string/JSON InlineKeyboardMarkup object. See https://core.telegram.org/bots/api#inlinekeyboardmarkup
*/
function ikb(array $options) {
	$lines = [];
	foreach ($options as $line_pos => $line_buttons) {
		$lines[$line_pos] = [];
		foreach ($line_buttons as $button_pos => $button) {
			$lines[$line_pos][$button_pos] = btn(...$button);
		}
	}
	$replyMarkup = [
		'inline_keyboard' => $lines,
	];
	return json_encode($replyMarkup, 480);
}
 
/**
* Build a RepkyKeyboardRemove object.
*
* @param bool (Optional) $selective If TRUE, the keyboard will disappear only for certain users. Default is TRUE.
*
* return string/JSON RepkyKeyboardRemove object. See https://core.telegram.org/bots/api#replykeyboardremove
*/
function hide_kb(bool $selective = TRUE) {
	$replyMarkup = [
		'remove_keyboard' => TRUE,
		'selective' => $selective,
	];
	return json_encode($replyMarkup, 480);
}
 
/**
* Build a ForceReply object.
*
* @param bool (Optional) $selective If TRUE, the forceReply will affect only to certain users. Default is TRUE.
*
* return string/JSON ForceReply object. See https://core.telegram.org/bots/api#forcereply
*/
function forceReply(bool $selective = TRUE) {
	$replyMarkup = [
		'force_reply' => TRUE,
		'selective' => $selective,
	];
	return json_encode($replyMarkup, 480);
}